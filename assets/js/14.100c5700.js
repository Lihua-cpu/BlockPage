(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{339:function(s,n,a){s.exports=a.p+"assets/img/1.a1a312d7.png"},340:function(s,n,a){s.exports=a.p+"assets/img/2.f1ccf067.png"},341:function(s,n,a){s.exports=a.p+"assets/img/3.f6045c42.png"},478:function(s,n,a){"use strict";a.r(n);var t=a(2),r=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"一、前沿"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、前沿"}},[s._v("#")]),s._v(" 一、前沿")]),s._v(" "),n("p",[s._v("亮点：")]),s._v(" "),n("p",[s._v("1、思维导图")]),s._v(" "),n("p",[s._v("2、工具推荐")]),s._v(" "),n("p",[s._v("3、参考资料")]),s._v(" "),n("h1",{attrs:{id:"一、思维导图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、思维导图"}},[s._v("#")]),s._v(" 一、思维导图")]),s._v(" "),n("p",[s._v("三个思维导图：前面两个是什么语言都是通用的，第三个是基于js的，可以结合前面两个和js语言特点来实现。")]),s._v(" "),n("p",[s._v("这三个思维导图还是挺有保存意义的")]),s._v(" "),n("h2",{attrs:{id:"计算机数据结构思维导图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#计算机数据结构思维导图"}},[s._v("#")]),s._v(" 计算机数据结构思维导图")]),s._v(" "),n("div",[n("img",{attrs:{src:a(339)}})]),s._v(" "),n("h2",{attrs:{id:"计算机算法思维导图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#计算机算法思维导图"}},[s._v("#")]),s._v(" 计算机算法思维导图")]),s._v(" "),n("div",[n("img",{attrs:{src:a(340)}})]),s._v(" "),n("h2",{attrs:{id:"js数据结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js数据结构"}},[s._v("#")]),s._v(" JS数据结构")]),s._v(" "),n("div",[n("img",{attrs:{src:a(341)}})]),s._v(" "),n("h1",{attrs:{id:"二、概要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、概要"}},[s._v("#")]),s._v(" 二、概要")]),s._v(" "),n("p",[s._v("了解数据结构后，了解算法，一般是一些常用的算法掌握了就差不多能应对大部分的。常见的就是排序算法、动态规划、贪心、窗口移动等等算法，围绕的主要是数组、链表，还有一些树的结构。")]),s._v(" "),n("p",[s._v("总结：")]),s._v(" "),n("ul",[n("li",[s._v("算法主要关注解决问题、时间复杂度、空间复杂度")]),s._v(" "),n("li",[n("strong",[s._v("算法通常来说都是时间换空间、空间换时间")])])]),s._v(" "),n("h1",{attrs:{id:"三、工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、工具"}},[s._v("#")]),s._v(" 三、工具")]),s._v(" "),n("p",[s._v("刷题工具：leetCode-cn、牛课网、leetCode")]),s._v(" "),n("p",[s._v("编译工具：vscode、webstorm、idea（非商用都免费）")]),s._v(" "),n("p",[s._v("算法可视化：https://visualgo.net/zh")]),s._v(" "),n("h1",{attrs:{id:"四、递归-分治"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、递归-分治"}},[s._v("#")]),s._v(" 四、递归/分治")]),s._v(" "),n("h2",{attrs:{id:"分治"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分治"}},[s._v("#")]),s._v(" 分治")]),s._v(" "),n("p",[s._v("思路")]),s._v(" "),n("p",[s._v("归并排序的基本思路是：")]),s._v(" "),n("ol",[n("li",[s._v("将数组分成两半。")]),s._v(" "),n("li",[s._v("递归地对每一半进行排序。")]),s._v(" "),n("li",[s._v("将两个已排序的子数组合并成一个最终的排序数组。")])]),s._v(" "),n("p",[s._v("基于js实现")]),s._v(" "),n("div",{staticClass:"language-vue line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-vue"}},[n("code",[s._v("function mergeSort(arr) {\n    // 基本情况：如果数组长度小于等于1，返回该数组\n    if (arr.length <= 1) {\n        return arr;\n    }\n\n    // 分割数组\n    const mid = Math.floor(arr.length / 2);\n    const left = mergeSort(arr.slice(0, mid));  // 递归排序左半部分\n    const right = mergeSort(arr.slice(mid));     // 递归排序右半部分\n\n    // 合并已排序的子数组\n    return merge(left, right);\n}\n\nfunction merge(left, right) {\n    const result = [];\n    let i = 0; // 左数组索引\n    let j = 0; // 右数组索引\n\n    // 合并两个已排序的数组\n    while (i < left.length && j < right.length) {\n        if (left[i] < right[j]) {\n            result.push(left[i]);\n            i++;\n        } else {\n            result.push(right[j]);\n            j++;\n        }\n    }\n\n    // 处理剩余的元素\n    return result.concat(left.slice(i)).concat(right.slice(j));\n}\n\n// 使用示例\nconst array = [38, 27, 43, 3, 9, 82, 10];\nconst sortedArray = mergeSort(array);\nconsole.log(sortedArray); // [3, 9, 10, 27, 38, 43, 82]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br")])]),n("p",[s._v("操作")]),s._v(" "),n("ul",[n("li",[s._v("递归分割："),n("code",[s._v("mergeSort")]),s._v(" 函数首先检查数组的长度。如果长度小于等于 1，直接返回数组，因为它已经是排序好的。")]),s._v(" "),n("li",[s._v("合并步骤："),n("code",[s._v("merge")]),s._v(" 函数负责合并两个已排序的数组。通过两个指针分别遍历左边和右边的数组，将较小的元素放入结果数组中。")]),s._v(" "),n("li",[s._v("结果合并：最后，合并剩下的未处理元素。")])]),s._v(" "),n("p",[s._v("总结")]),s._v(" "),n("p",[s._v("分治策略通过将复杂问题分解为简单子问题，从而利用递归简化解决过程。归并排序是分治算法的经典应用之一，适用于大规模数据的排序。")]),s._v(" "),n("h2",{attrs:{id:"递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[s._v("#")]),s._v(" 递归")]),s._v(" "),n("p",[s._v("概述：")]),s._v(" "),n("p",[s._v("递归是一种编程技巧，在函数内部调用自身以解决问题。使用递归的关键是确保每次调用都在向基例（终止条件）靠近，并能够有效地解决子问题。下面是一些经典的递归实现示例")]),s._v(" "),n("p",[s._v("例子：")]),s._v(" "),n("div",{staticClass:"language-vue line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-vue"}},[n("code",[s._v("function factorial(n) {\n    // 基本情况：0! = 1\n    if (n === 0) {\n        return 1;\n    }\n    // 递归情况\n    return n * factorial(n - 1);\n}\n\n// 使用示例\nconsole.log(factorial(5)); // 120\nfunction fibonacci(n) {\n    // 基本情况\n    if (n === 0) {\n        return 0;\n    }\n    if (n === 1) {\n        return 1;\n    }\n    // 递归情况\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// 使用示例\nconsole.log(fibonacci(6)); // 8\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br")])]),n("h1",{attrs:{id:"五、贪心算法-动态规划"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五、贪心算法-动态规划"}},[s._v("#")]),s._v(" 五、贪心算法/动态规划")]),s._v(" "),n("h2",{attrs:{id:"贪心算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[s._v("#")]),s._v(" 贪心算法")]),s._v(" "),n("p",[s._v("贪心是每次的最优解、动态是全局的最优解")]),s._v(" "),n("p",[s._v("概述：")]),s._v(" "),n("p",[s._v("贪心算法是一种通过局部最优选择来寻找全局最优解的方法。下面是一个简单的例子，使用贪心算法解决最少硬币问题。")]),s._v(" "),n("div",{staticClass:"language-vue line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-vue"}},[n("code",[s._v("function minCoins(coins, amount) {\n    // 按照面额从大到小排序\n    coins.sort((a, b) => b - a);\n    \n    let count = 0;\n    \n    for (let coin of coins) {\n        while (amount >= coin) {\n            amount -= coin;\n            count++;\n        }\n    }\n    \n    // 如果amount为0，返回硬币数量，否则返回-1表示无法凑成\n    return amount === 0 ? count : -1;\n}\n\n// 使用示例\nconst coins = [1, 5, 10, 25]; // 硬币面额\nconst amount = 63; // 目标金额\nconsole.log(minCoins(coins, amount)); // 输出最少硬币数量\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])]),n("p",[s._v("总结：")]),s._v(" "),n("p",[s._v("在这个示例中，我们通过从大到小选择硬币，尽量用最少的硬币达到目标金额。这种方法在一些特定情况下是有效的，但并不适用于所有问题，因此在使用贪心算法时，需要确保其适用性。")]),s._v(" "),n("h2",{attrs:{id:"动态递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态递归"}},[s._v("#")]),s._v(" 动态递归")]),s._v(" "),n("p",[s._v("思路：")]),s._v(" "),n("p",[s._v("动态规划是一种解决问题的有效方法，特别适用于具有重叠子问题和最优子结构性质的问题。下面通过一个经典的例子——最长公共子序列 (LCS)，展示如何使用 JavaScript 实现动态规划。")]),s._v(" "),n("div",{staticClass:"language-vue line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-vue"}},[n("code",[s._v('function longestCommonSubsequence(str1, str2) {\n    const m = str1.length;\n    const n = str2.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (str1[i - 1] === str2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// 使用示例\nconst str1 = "AGGTAB";\nconst str2 = "GXTXAYB";\nconsole.log(longestCommonSubsequence(str1, str2)); // 输出 4\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br")])]),n("p",[s._v("总结")]),s._v(" "),n("p",[s._v("动态规划通常用于解决优化问题，采用分阶段的策略，解决小问题并将其结果存储，以避免重复计算。通过自顶向下或自底向上的方式，我们可以高效地实现动态规划，显著提高性能。")]),s._v(" "),n("h1",{attrs:{id:"六、排序算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#六、排序算法"}},[s._v("#")]),s._v(" 六、排序算法")]),s._v(" "),n("p",[s._v("关于Array.sort")]),s._v(" "),n("p",[s._v("实际生产中，使用排序最多的是Array.sort()，")]),s._v(" "),n("p",[s._v("JavaScript 中的 "),n("code",[s._v("Array.sort()")]),s._v(" 方法在不同的 JavaScript 引擎中使用不同的排序算法，但大多数现代浏览器（如 Chrome 和 Firefox）使用的是一种名为 Timsort 的算法。Timsort 是基于归并排序和插入排序的混合算法，旨在处理现实世界中的数据并优化排序性能。")]),s._v(" "),n("h3",{attrs:{id:"时间复杂度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[s._v("#")]),s._v(" 时间复杂度")]),s._v(" "),n("ul",[n("li",[s._v("最坏情况：O(n log n)")]),s._v(" "),n("li",[s._v("平均情况：O(n log n)")]),s._v(" "),n("li",[s._v("最好情况：O(n)（当数组已经基本有序时）")])]),s._v(" "),n("p",[s._v("Timsort 通过将数组分成小块（称为“run”），然后对这些小块进行排序，最后合并这些已排序的小块来达到高效排序的目的。因此，在处理部分有序的数据时，Timsort 的性能尤为出色。")]),s._v(" "),n("p",[s._v("值得注意的是，"),n("code",[s._v("Array.sort()")]),s._v(" 方法的实现不一定是稳定的，这意味着相同元素的顺序可能在排序后发生变化。不同的引擎可能对此有不同的实现细节。")]),s._v(" "),n("p",[s._v("一般来说十大排序：")]),s._v(" "),n("ol",[n("li",[s._v("冒泡排序（Bubble Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("简单易懂，通过重复交换相邻的元素来排序。")])])])]),s._v(" "),n("ol",[n("li",[s._v("选择排序（Selection Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("每次找到未排序部分的最小元素，放到已排序部分的末尾。")])])])]),s._v(" "),n("ol",[n("li",[s._v("插入排序（Insertion Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("将元素逐一插入到已排序的部分，适合小规模数据。")])])])]),s._v(" "),n("ol",[n("li",[s._v("归并排序（Merge Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("采用分治法，先分成小数组，再合并排序。")])])])]),s._v(" "),n("ol",[n("li",[s._v("快速排序（Quick Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("选择一个“基准”元素，将数组分为两部分，递归排序。")])])])]),s._v(" "),n("ol",[n("li",[s._v("堆排序（Heap Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("利用堆数据结构进行排序，时间复杂度较优。")])])])]),s._v(" "),n("ol",[n("li",[s._v("计数排序（Counting Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("适用于范围较小的整数，通过计数实现排序。")])])])]),s._v(" "),n("ol",[n("li",[s._v("基数排序（Radix Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("将数据按位数分组，逐位排序，适合大规模整数。")])])])]),s._v(" "),n("ol",[n("li",[s._v("桶排序（Bucket Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("将数据分到多个桶中，再对每个桶内的数据排序。")])])])]),s._v(" "),n("ol",[n("li",[s._v("希尔排序（Shell Sort）")])]),s._v(" "),n("ul",[n("li",[n("ul",[n("li",[s._v("通过间隔分组进行插入排序，逐步减少间隔。")])])])]),s._v(" "),n("h1",{attrs:{id:"参考资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")]),s._v(" "),n("p",[s._v("1、https://blog.csdn.net/weixin_46228563/article/details/138238235")]),s._v(" "),n("p",[s._v("2、https://visualgo.net/zh")])])}),[],!1,null,null,null);n.default=r.exports}}]);